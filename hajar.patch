diff --git a/execve.c b/execve.c
index 9de4784..21ee8c8 100644
--- a/execve.c
+++ b/execve.c
@@ -124,6 +124,7 @@ int	execute_basic_cmd(t_commande *cmd, t_environment *env_copy)
 		printf("Malloc error\n");
 		return (1);
 	}
+	// TODO create a list_to_array
 	if (execve(full_path, argv, NULL) == -1)
 		ft_error(cmd->cmd);
 	free_argv(argv);
diff --git a/execve_utils.c b/execve_utils.c
index afb29f2..4f61466 100644
--- a/execve_utils.c
+++ b/execve_utils.c
@@ -50,12 +50,12 @@ char	*segment_malloc_copy(char *segment, char *token_start, char *token_end)
 
 void	copy_the_path(t_environment *env_copy, t_epi *epi)
 {
-	int		i;
+	t_environment	*curr;
 
-	i = 0;
-	while (env_copy[i].key != NULL && strcmp(env_copy[i].key, "PATH") != 0)
-		i++;
-	epi->path = ft_strdup(env_copy[i].value);
+	curr = env_copy;
+	while (curr->key != NULL && strcmp(curr->key, "PATH") != 0)
+		curr = curr->next;
+	epi->path = ft_strdup(curr->value);
 	epi->tok_s = epi->path;
 }
 
diff --git a/expand_variable.c b/expand_variable.c
index 1ac9c89..70122a0 100644
--- a/expand_variable.c
+++ b/expand_variable.c
@@ -60,19 +60,16 @@ char	*find_env_variable(t_type *node)
 //then copies back the value of this variable
 char	*retrieve_env_variable(char *env_var, t_environment *env)
 {
-	int	i;
-
 	if (env_var == NULL || env == NULL)
 		return (NULL);
-	i = 0;
-	while (env[i].key != NULL)
+
+	t_environment *cur = env;
+	while (cur)
 	{
-		if (env[i].key != NULL && env[i].value != NULL)
-		{
-			if (ft_strcmp(env_var, env[i].key) == 0)
-				return (ft_strdup(env[i].value));
-		}
-		i++;
+		if (cur->key != NULL && cur->value != NULL)
+			if (!ft_strcmp(env_var, cur->key))
+				return (ft_strdup(cur->value));
+		cur = cur->next;
 	}
 	return (NULL);
 }
diff --git a/init.c b/init.c
index eb221e3..c7b9f86 100644
--- a/init.c
+++ b/init.c
@@ -18,19 +18,63 @@ void	init_prompt(char *input)
 	ft_welcome();
 }
 
+t_environment *new_env_node(char *env)
+{
+	t_environment	*ptr;
+	char 			*del;
+	int				key;
+	int 			val;
+
+	ptr = NULL;
+	del = ft_strchr(env, '=');
+	if (del != NULL)
+	{
+		key = del - env;
+		val = ft_strlen(del + 1);
+		ptr = (t_environment*)malloc(sizeof(t_environment));
+		ptr->key = (char*) malloc(key + 1);
+		ptr->value = (char *) malloc(val + 1);
+		if(!ptr || !ptr->key || !ptr->value)
+			perror("Failed to allocate a new node");
+		ft_strncpy(ptr->key, env, key);
+		ptr->key[key] = '\0';
+		// TODO CHANGE ME
+		ft_strcpy(ptr->value, del + 1);
+		ptr->value[val] = '\0';
+	}
+	return (ptr);
+}
+
 t_environment	*init_env(char **envp)
 {
-	t_environment	*env_copy;
-	int				i;
+	t_environment	*head;
+	t_environment	*curr;
+	t_environment	*new_ptr;
+	int				count;
+	int 			i;
 
-	env_copy = copy_env(envp);
 	i = 0;
-	while (env_copy[i].key != NULL)
+	head = NULL;
+	count = env_count(envp);
+	head = NULL;
+	curr = NULL;
+	while (i < count)
 	{
-		/* printf("Key: %s, Value: %s\n", env_copy[i].key, env_copy[i].value); */
+		new_ptr = new_env_node(envp[i]);
+		if (head == NULL)
+		{
+			head = new_ptr;
+			curr = new_ptr;
+		}
+		else
+		{
+			curr->next = new_ptr;
+			curr = new_ptr;
+		}
 		i++;
 	}
-	return (env_copy);
+	curr->next = NULL;
+	return (head);
 }
 
 // Function to initiate parsing to transform input into blocks
@@ -76,40 +120,6 @@ int	init_tokenizer(char **blocks, t_environment *env_copy)
 	{
 		return (-1);
 	}
-	/* printf("\nPipe nbr is %d and Cmd nbr is %d\n\n", */
-	/* 	pipe_count, cmd_count); */
-	/* if (cmd_lst != NULL) */
-	/* { */
-	/* 	/1* printf("Command list:\n"); *1/ */
-	/* 	print_commande_list(cmd_lst); */
-	/* } */
-	/* if (is_odd_or_even(&pipe_count, &cmd_count) == 3) */
-	/* { */
-	/* 	if (tokens->type == 1) */
-	/* 		which_builtin(cmd_lst); */
-	/* 	else if (tokens->type == 0) */
-	/* 	{ */
-	/* 		while (tokens != NULL) */
-	/* 		{ */
-	/* 			if (tokens->type == 9) */
-	/* 			{ */
-	/* 				/1* printf("je suis execute_redir\n"); *1/ */
-	/* 				execute_redir(cmd_lst, env_copy); */
-	/* 				flag = 1; */
-	/* 				break ; */
-	/* 			} */
-	/* 			tokens = tokens->next; */
-	/* 		} */
-	/* 		if (flag == 0) */
-	/* 		{ */
-	/* 			/1* printf("je suis only_one_cmd\n"); *1/ */
-	/* 			only_one_cmd(cmd_lst, env_copy); */
-	/* 		} */
-	/* 	} */
-	/* } */
-	/* else if (is_odd_or_even(&pipe_count, &cmd_count) == 1 */
-	/* 	|| is_odd_or_even(&pipe_count, &cmd_count) == 2) */
-	/* 	execute_pipeline(cmd_lst, env_copy); */
 	assign_fds(cmd_lst);
 	while (cmd_lst != NULL)
 	{
diff --git a/minishell.c b/minishell.c
index abcf3d3..e187a01 100644
--- a/minishell.c
+++ b/minishell.c
@@ -22,38 +22,24 @@
 
 int	g_status = 0;
 
-/* void print_environment_list(t_environment *head) */
-/* { */
-/* 	int node_number = 1; */
-/* 	t_environment *current = head; */
-/* 	while (current != NULL) */
-/* 	{ */
-/* 		if (current->key != NULL && current->value != NULL) */
-/* 		{ */
-/* 			printf("Node %d: key -> %s, value -> %s\n", node_number, current->key, current->value); */
-/* 		} */
-/* 		else */
-/* 		{ */
-/* 			printf("Node %d: Incomplete or corrupted data\n", node_number); */
-/* 			break; */
-/* 		} */
-
-/* 		current = current->next; */
-/* 		node_number++; */
-/* 	} */
-/* } */
-
 int	main(int ac, char **av, char **envp)
 {
 	char			**blocks;
 	char			*input;
-	t_environment	*env_copy;
+	t_environment	*head;
 
 	input = NULL;
 	(void)ac;
 	(void)av;
 	init_prompt(input);
-	env_copy = init_env(envp);
+	head = init_env(envp);
+//	t_environment *iter;
+//	iter = head;
+//	while (iter)
+//	{
+//		printf("%s = %s\n", iter->key, iter->value);
+//		iter = iter->next;
+//	}
 	while (1)
 	{
 		input = ft_prompt();
@@ -80,7 +66,7 @@ int	main(int ac, char **av, char **envp)
 				input = remove_xtra_spaces(input);
 			/* printf("Cleaned input is : %s\n", input); */
 			blocks = init_parse(input);
-			if (init_tokenizer(blocks, env_copy) == -1)
+			if (init_tokenizer(blocks, head) == -1)
 			{
 				printf("Error: %s: command not found\n", input);
 				handling_signals(input);
diff --git a/minishell.h b/minishell.h
index 3c1caf1..a33ba79 100644
--- a/minishell.h
+++ b/minishell.h
@@ -170,6 +170,7 @@ int				check_path(char *path);
 
 t_environment	*copy_env(char **envp);
 void			free_env_struct(t_environment *env_struct);
+int				env_count(char **envp);
 
 /* ooo - clean_cmd - ooo */
 
